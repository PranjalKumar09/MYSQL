
NOT NULL
========

$ desc customers;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(100) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

$ insert into customers(id)   values (132);
$ select * from customers;
+------+---------+
| id   | name    |
+------+---------+
|  411 | Pranjal |
|  101 | Ajmal   |
|  132 | NULL    |
+------+---------+

$ insert into customers values(NULL, NULL); 
Possible

    There is no sense in adding the null, to handle this

$ Create table customers 
    (
        id int not null ,
        name varchar(100) not null
    );

$  desc customer2;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | NO   |     | NULL    |       |
| name  | varchar(100) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

Now we can't insert the null either way



Default
=======
    While inserting when we not assign value for particular column, default assigned to it. 
    Can used when we know that many will value will same in list

    $ create table customer3 ( id int not null , name varchar(50) not null, acc_type varchar(100) not null default 'Savings'); 

    $ desc customer3;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    |       |
| name     | varchar(50)  | NO   |     | NULL    |       |
| acc_type | varchar(100) | NO   |     | Savings |       |
+----------+--------------+------+-----+---------+-------+

    $ insert into customer3(id , name) values(123, "Kr");

    $ select * from customer3;
+-----+------+----------+
| id  | name | acc_type |
+-----+------+----------+
| 123 | Kr   | Savings  |
+-----+------+----------+





Primary Key
===========
    The primary key constraint uniquely indentifies each record in table .
    Primary key must contain UNIQUE values , & vannot containe NULL values.
    A table can have only ONE primary key

    $ create table customeers4 ( acc_no int primary key, name varchar(50) not null , acc_type  varchar(50) not null default 'Savuings');

    $  desc customeers4 ;
+----------+-------------+------+-----+----------+-------+
| Field    | Type        | Null | Key | Default  | Extra |
+----------+-------------+------+-----+----------+-------+
| acc_no   | int         | NO   | PRI | NULL     |       |
| name     | varchar(50) | NO   |     | NULL     |       |
| acc_type | varchar(50) | NO   |     | Savuings |       |
+----------+-------------+------+-----+----------+-------+

$ insert into customeers4(acc_no, name) values(001, "Pranjal");

$ select * from customeers4;
+--------+---------+----------+
| acc_no | name    | acc_type |
+--------+---------+----------+
|      1 | Pranjal | Savuings |
+--------+---------+----------+

$ insert into customeers4(acc_no, name) values(001, "Ram");
ERROR 1062 (23000): Duplicate entry '1' for key 'customeers4.PRIMARY'

Primary keys must contain UNIQUE values, and cannot contain NULL values


Auto Increment
---------------
$ create table customers (acc_no int primary key auto_increment, name varchar(100) not null,  acc_type varchar(50) not null default 'Savings');
$  desc customers;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| acc_no   | int          | NO   | PRI | NULL    | auto_increment |
| name     | varchar(100) | NO   |     | NULL    |                |
| acc_type | varchar(50)  | NO   |     | Savings |                |
+----------+--------------+------+-----+---------+----------------+

$ insert into customers(name) values("Raju"), ("Sham");

$ mysql> select * from customers;
+--------+------+----------+
| acc_no | name | acc_type |
+--------+------+----------+
|      1 | Raju | Savings  |
|      2 | Sham | Savings  |
+--------+------+----------+

$ insert into customers(acc_no , name) values(145,"Baburao"), (121,
"TotolaBhai");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
+--------+------------+----------+

$ insert into customers(name) values("Raskhan");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
|    146 | Raskhan    | Savings  |
+--------+------------+----------+


Alias
=====
    To do more readable

$ select acc_no as "Account Number" from customers;
+----------------+
| Account Number |
+----------------+
|              1 |
|              2 |
|            121 |
|            145 |
|            146 |
+----------------+

Even more than one poxsib
$ select acc_no as "Account Number", name as "Customer Names" from customers;
+----------------+----------------+
| Account Number | Customer Names |
+----------------+----------------+
|              1 | Raju           |
|              2 | Sham           |
|            121 | TotolaBhai     |
|            145 | Baburao        |
|            146 | Raskhan        |
+----------------+----------------+




DISTINCT
========

    $ select dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Loan    |
| Account |
| Deposit |
+---------+
5 rows in set (0.00 sec)

    $ select distinct dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Account |
| Deposit |
+---------+



    When it used with multiple column then only distinct combo will come (means it will not for particular check with all distinct columns)


    $  select fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
| Baburao | Apte    |
+---------+---------+

    $ select distinct fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
+---------+---------+






    ORDER UP
    ========
    Used for sorting 
    For Descending order -> DESC 

    $ select * from employee2 order by fname ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    105 | Alex    | Watt    | Associate  | Deposit |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    104 | Paul    | Philip  | Accountant | Account |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    102 | Sham    | Mohan   | Casier     | Cash    |
+--------+---------+---------+------------+---------+

    $ select * from employee2 order by fname desc ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    102 | Sham    | Mohan   | Casier     | Cash    |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    104 | Paul    | Philip  | Accountant | Account |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    105 | Alex    | Watt    | Associate  | Deposit |
+--------+---------+---------+------------+---------+


    Now we can do do sorting by prefrence also   ORDER BY   prefer1_column1 , prefer2_column2


