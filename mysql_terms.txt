
NOT NULL
========

$ desc customers;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(100) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

$ insert into customers(id)   values (132);
$ select * from customers;
+------+---------+
| id   | name    |
+------+---------+
|  411 | Pranjal |
|  101 | Ajmal   |
|  132 | NULL    |
+------+---------+

$ insert into customers values(NULL, NULL); 
Possible

    There is no sense in adding the null, to handle this

$ Create table customers 
    (
        id int not null ,
        name varchar(100) not null
    );

$  desc customer2;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | NO   |     | NULL    |       |
| name  | varchar(100) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

Now we can't insert the null either way



Default
=======
    While inserting when we not assign value for particular column, default assigned to it. 
    Can used when we know that many will value will same in list

    $ create table customer3 ( id int not null , name varchar(50) not null, acc_type varchar(100) not null default 'Savings'); 

    $ desc customer3;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    |       |
| name     | varchar(50)  | NO   |     | NULL    |       |
| acc_type | varchar(100) | NO   |     | Savings |       |
+----------+--------------+------+-----+---------+-------+

    $ insert into customer3(id , name) values(123, "Kr");

    $ select * from customer3;
+-----+------+----------+
| id  | name | acc_type |
+-----+------+----------+
| 123 | Kr   | Savings  |
+-----+------+----------+





Primary Key
===========
    The primary key constraint uniquely indentifies each record in table .
    Primary key must contain UNIQUE values , & vannot containe NULL values.
    A table can have only ONE primary key

    $ create table customeers4 ( acc_no int primary key, name varchar(50) not null , acc_type  varchar(50) not null default 'Savuings');

    $  desc customeers4 ;
+----------+-------------+------+-----+----------+-------+
| Field    | Type        | Null | Key | Default  | Extra |
+----------+-------------+------+-----+----------+-------+
| acc_no   | int         | NO   | PRI | NULL     |       |
| name     | varchar(50) | NO   |     | NULL     |       |
| acc_type | varchar(50) | NO   |     | Savuings |       |
+----------+-------------+------+-----+----------+-------+

$ insert into customeers4(acc_no, name) values(001, "Pranjal");

$ select * from customeers4;
+--------+---------+----------+
| acc_no | name    | acc_type |
+--------+---------+----------+
|      1 | Pranjal | Savuings |
+--------+---------+----------+

$ insert into customeers4(acc_no, name) values(001, "Ram");
ERROR 1062 (23000): Duplicate entry '1' for key 'customeers4.PRIMARY'

Primary keys must contain UNIQUE values, and cannot contain NULL values


Auto Increment
---------------
It applies only to primary key 
$ create table customers (acc_no int primary key auto_increment, name varchar(100) not null,  acc_type varchar(50) not null default 'Savings');
$  desc customers;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| acc_no   | int          | NO   | PRI | NULL    | auto_increment |
| name     | varchar(100) | NO   |     | NULL    |                |
| acc_type | varchar(50)  | NO   |     | Savings |                |
+----------+--------------+------+-----+---------+----------------+

$ insert into customers(name) values("Raju"), ("Sham");

$ mysql> select * from customers;
+--------+------+----------+
| acc_no | name | acc_type |
+--------+------+----------+
|      1 | Raju | Savings  |
|      2 | Sham | Savings  |
+--------+------+----------+

$ insert into customers(acc_no , name) values(145,"Baburao"), (121,
"TotolaBhai");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
+--------+------------+----------+

$ insert into customers(name) values("Raskhan");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
|    146 | Raskhan    | Savings  |
+--------+------------+----------+


Alias
=====
    To do more readable

$ select acc_no as "Account Number" from customers;
+----------------+
| Account Number |
+----------------+
|              1 |
|              2 |
|            121 |
|            145 |
|            146 |
+----------------+

Even more than one poxsib
$ select acc_no as "Account Number", name as "Customer Names" from customers;
+----------------+----------------+
| Account Number | Customer Names |
+----------------+----------------+
|              1 | Raju           |
|              2 | Sham           |
|            121 | TotolaBhai     |
|            145 | Baburao        |
|            146 | Raskhan        |
+----------------+----------------+




DISTINCT
========

    $ select dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Loan    |
| Account |
| Deposit |
+---------+
5 rows in set (0.00 sec)

    $ select distinct dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Account |
| Deposit |
+---------+



    When it used with multiple column then only distinct combo will come (means it will not for particular check with all distinct columns)


    $  select fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
| Baburao | Apte    |
+---------+---------+

    $ select distinct fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
+---------+---------+






    ORDER UP
    ========
    Used for sorting 
    For Descending order -> DESC 

    $ select * from employee2 order by fname ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    105 | Alex    | Watt    | Associate  | Deposit |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    104 | Paul    | Philip  | Accountant | Account |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    102 | Sham    | Mohan   | Casier     | Cash    |
+--------+---------+---------+------------+---------+

    $ select * from employee2 order by fname desc ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    102 | Sham    | Mohan   | Casier     | Cash    |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    104 | Paul    | Philip  | Accountant | Account |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    105 | Alex    | Watt    | Associate  | Deposit |
+--------+---------+---------+------------+---------+


    Now we can do do sorting by prefrence also   ORDER BY   column1 ,column2 ---;

    column1 is sorted first , then if column1 same then rest column2 prefer like this continues.



LIKE
=====
    Even works bettwer with different case (lowercase or uppercase)

    $ select * from  employees;
+--------+--------+------------+---------+
| emp_id | name   | desig      | dept    |
+--------+--------+------------+---------+
|    101 | Raju   | Manager    | Loan    |
|    103 | Paul   | Associate  | IT      |
|    104 | Alex   | Accountant | Account |
|    105 | Victor | Associate  | Deposit |
+--------+--------+------------+---------+

    $ select * from employees where desig like "%mAna%";
+--------+------+---------+------+
| emp_id | name | desig   | dept |
+--------+------+---------+------+
|    101 | Raju | Manager | Loan |
+--------------------------------+


    $ select * from  employees where name like "_a__";
+--------+------+-----------+------+
| emp_id | name | desig     | dept |
+--------+------+-----------+------+
|    101 | Raju | Manager   | Loan |
|    103 | Paul | Associate | IT   |
+--------+------+-----------+------+

    $ select * from employee2  where fname like "L*" or fname like "%s"1 row in set (0.01 sec)


LIMIT 
=====
    Its for showing only limited columns

    $ select * from  employee2 ;
+--------+---------+----------+------------+------------+
| emp_id | fname   | lname    | desig      | dept       |
+--------+---------+----------+------------+------------+
|    101 | Raju    | Rastogi  | Manager    | Loan       |
|    102 | Sham    | Mohan    | Casier     | Cash       |
|    103 | Baburao | Apte     | Associate  | Loan       |
|    104 | Paul    | Philip   | Accountant | Account    |
|    105 | Alex    | Watt     | Associate  | Deposit    |
|    106 | Baburao | Apte     | Casier     | Account    |
|    107 | James   | Moore    | Assistant  | HR         |
|    108 | David   | Brown    | Consultant | Sales      |
|    109 | David   | Davis    | Cashier    | Sales      |
|    110 | David   | Smith    | Analyst    | Operations |
|    111 | Michael | Brown    | Assistant  | Credit     |
|    112 | Lisa    | Miller   | Officer    | Sales      |
|    113 | Emily   | Johnson  | Clerk      | Accounts   |
|    114 | John    | Wilson   | Executive  | Compliance |



    $  select * from  employee2 limit 4 ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    102 | Sham    | Mohan   | Casier     | Cash    |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    104 | Paul    | Philip  | Accountant | Account |
+--------+---------+---------+------------+---------+


    It can also be used with two to perform as range 
    LIMIT <start-1>, <no of terms> ;


   $ select * from  employee2 limit 4,5;
+--------+---------+---------+------------+------------+
| emp_id | fname   | lname   | desig      | dept       |
+--------+---------+---------+------------+------------+
|    105 | Alex    | Watt    | Associate  | Deposit    |
|    106 | Baburao | Apte    | Casier     | Account    |
|    107 | James   | Moore   | Assistant  | HR         |
|    108 | David   | Brown   | Consultant | Sales      |
|    109 | David   | Davis   | Cashier    | Sales      |
+--------+---------+---------+------------+------------+
 

   $ select * from employee2 order by fname desc limit 1;
+--------+-------+-------+--------+------+--------+
| emp_id | fname | lname | desig  | dept | salary |
+--------+-------+-------+--------+------+--------+
|    102 | Sham  | Mohan | Casier | Cash |  25000 |
+--------+-------+-------+--------+------+--------+




    COUNT 
    ====== 

   $  select count(*) from employees;
+----------+
| count(*) |
+----------+
|        4 |
+----------+

    $ select count(name) from employees;
+-------------+
| count(name) |
+-------------+
|           4 |
+-------------+


    $ select count(desig) from employees;
+--------------+
| count(desig) |
+--------------+
|            4 |
+--------------+

    To select the disctinct the desig;
    $ select count(distinct desig) from employees;
+-----------------------+
| count(distinct desig) |
+-----------------------+
|                     3 |
+-----------------------+

    Also can used in conditional counts 
    $ select count(*) from employee2 where dept="HR";
+----------+
| count(*) |
+----------+
|       27 |
+----------+


    GROUP BY
    ----- --
    =========

    $ SELECT DEPT  FROM employee2 GROUP by dept;
+------------+
| DEPT       |
+------------+
| Loan       |
| Cash       |
| Account    |
| Deposit    |
| HR         |
| Sales      |
| Operations |
| Credit     |
| Accounts   |
| Compliance |
| IT         |
| Loans      |
+------------+

    $ SELECT DEPT , COUNT(FNAME) from employee2 group by dept;
+------------+--------------+
| DEPT       | COUNT(FNAME) |
+------------+--------------+
| Loan       |            2 |
| Cash       |            1 |
| Account    |            2 |
| Deposit    |            1 |
| HR         |           27 |
| Sales      |           38 |
| Operations |           34 |
| Credit     |           40 |
| Accounts   |           44 |
| Compliance |           41 |
| IT         |           42 |
| Loans      |           34 |
+------------+--------------+

    Agrreate function dont work in ditinct , by it work in group by




    MAX & MIN
    ===========
    
        $  select max(salary) from employee2;
+-------------+
| max(salary) |
+-------------+
|       99978 |
+-------------+
1 row in set (0.00 sec)

     $ select min(salary) from employee2;
+-------------+
| min(salary) |
+-------------+
|       10651 |
+-------------+





    SUB QUERIS
    ============
    $ select emp_id , fname ,  salary from employee2 where salary = (select max(salary) from employee2);
+--------+-------+--------+
| emp_id | fname | salary |
+--------+-------+--------+
|    329 | Sarah |  99978 |
+--------+-------+--------+



    SUM & AVG
    =========
     $ select sum(salary) from employee2;
+-------------+
| sum(salary) |
+-------------+
|    16663255 |
+-------------+

    $  select avg(salary) from employee2;
+-------------+
| avg(salary) |
+-------------+
|  54455.0817 |
+-------------+


    $  SELECT dept ,COUNT(emp_id), SUM(salary) from employee2 group by dept;
+------------+---------------+-------------+
| dept       | COUNT(emp_id) | SUM(salary) |
+------------+---------------+-------------+
| Loan       |             2 |       91208 |
| Cash       |             1 |       12300 |
| Account    |             2 |       84997 |
| Deposit    |             1 |       23945 |
| HR         |            27 |     1337107 |
| Sales      |            38 |     2059159 |
| Operations |            34 |     2039809 |
| Credit     |            40 |     1969506 |
| Accounts   |            44 |     2534715 |
| Compliance |            41 |     2219227 |
| IT         |            42 |     2326295 |
| Loans      |            34 |     1964987 |
+------------+---------------+-------------+

    
    Sum by conditions

    $ select sum(salary) from employee2 where dept="Loan";
+-------------+
| sum(salary) |
+-------------+
|       91208 |
+-------------+





DEFAULT and ON UPDATE 
=====================
    $ create table blogs( blog varchar(150), 
    ct datetime default current_timestamp, 
    ut datetime on update current_timestamp);

    This can use in like in tweets ine time stamp created on creation time , other when we are updating (on update).

    $ insert into blogs (blog) values("First Blog");
    $ select * from blogs;
+------------+---------------------+------+
| blog       | ct                  | ut   |
+------------+---------------------+------+
| First Blog | 2024-08-30 21:40:43 | NULL |
+------------+---------------------+------+

    $ update blogs set blog= "First Blog Updated";
    $ select * from blogs;
+--------------------+---------------------+---------------------+
| blog               | ct                  | ut                  |
+--------------------+---------------------+---------------------+
| First Blog Updated | 2024-08-30 21:40:43 | 2024-08-30 21:41:50 |
+--------------------+---------------------+---------------------+
 
    


IN and NOT IN
===============
    $ SELECT * from employee2 where fname in ('Jane' ,'David') limit 10; 
+--------+-------+----------+------------+------------+--------+
| emp_id | fname | lname    | desig      | dept       | salary |
+--------+-------+----------+------------+------------+--------+
|    108 | David | Brown    | Consultant | Sales      |  96017 |
|    109 | David | Davis    | Cashier    | Sales      |  93030 |
|    110 | David | Smith    | Analyst    | Operations |  57979 |
|    122 | Jane  | Johnson  | Executive  | Loans      |  38414 |
|    129 | Jane  | Brown    | Consultant | Compliance |  84416 |
|    131 | Jane  | Jones    | Officer    | Compliance |  17439 |
|    137 | Jane  | Jones    | Officer    | Compliance |  31988 |
|    140 | David | Miller   | Executive  | HR         |  60610 |
|    154 | Jane  | Miller   | Clerk      | Operations |  56079 |
|    159 | David | Williams | Officer    | IT         |  97338 |
+--------+-------+----------+------------+------------+--------+

    $ SELECT * from employee2 where fname not in ('Jane' ,'David') limit
+--------+---------+---------+------------+----------+--------+
| emp_id | fname   | lname   | desig      | dept     | salary |
+--------+---------+---------+------------+----------+--------+
|    101 | Raju    | Rastogi | Manager    | Loan     |  68647 |
|    102 | Sham    | Mohan   | Casier     | Cash     |  12300 |
|    103 | Baburao | Apte    | Associate  | Loan     |  22561 |
|    104 | Paul    | Philip  | Accountant | Account  |  23032 |
|    105 | Alex    | Watt    | Associate  | Deposit  |  23945 |
|    106 | Baburao | Apte    | Casier     | Account  |  61965 |
|    107 | James   | Moore   | Assistant  | HR       |  37101 |
|    111 | Michael | Brown   | Assistant  | Credit   |  86744 |
|    112 | Lisa    | Miller  | Officer    | Sales    |  47637 |
|    113 | Emily   | Johnson | Clerk      | Accounts |  22605 |
+--------+---------+---------+------------+----------+--------+




BETWEEN
=======
    Employees whoes salary is more than 10000 and Less than 40000;

    $ SELECT * from employee2 where salary<=40000 and salary>=10000;
    $ SELECT * from employee2 where salary between 10000 and 40000 ;
    both work same ranges included too.


CASE 
=====
    $ select  emp_id , fname , 
    case 
        when salary >= 40000 then "High Salary"
        else "Low Salary"
    end as "Salary Category"
    from employee2;

+--------+---------+-----------------+
| emp_id | fname   | Salary Category |
+--------+---------+-----------------+
|    101 | Raju    | High Salary     |
|    102 | Sham    | Low Salary      |
|    103 | Baburao | Low Salary      |
|    104 | Paul    | Low Salary      |
|    105 | Alex    | Low Salary      |
+--------+---------+-----------------+


    $ select  emp_id , fname , case 
    when salary >= 70000 then "High Salary" 
    WHEN salary >= 35000 then "Mid Salary" 
    else "Low Salary" end as "Salary Category" 
    from employee2 LIMIT 10;
+--------+---------+-----------------+
| emp_id | fname   | Salary Category |
+--------+---------+-----------------+
|    101 | Raju    | Mid Salary      |
|    102 | Sham    | Low Salary      |
|    103 | Baburao | Low Salary      |
|    104 | Paul    | Low Salary      |
|    105 | Alex    | Low Salary      |
|    106 | Baburao | Mid Salary      |
|    107 | James   | Mid Salary      |
|    108 | David   | High Salary     |
|    109 | David   | High Salary     |
|    110 | David   | Mid Salary      |
+--------+---------+-----------------+

    $ select emp_id , case when salary != 0 then salary/80 end as "Salary in Dollar" from employee2;
+--------+------------------+
| emp_id | Salary in Dollar |
+--------+------------------+
|    102 |         153.7500 |
|    103 |         282.0125 |
|    101 |         858.0875 |
+--------+------------------+


ISNULL  & NOR LIKE
==================
    Is null give true on null values 
    $ select * from employee2  where fname is null;


    $ select * from employee2  where fname like "R%";
+--------+-------+---------+---------+------+--------+
| emp_id | fname | lname   | desig   | dept | salary |
+--------+-------+---------+---------+------+--------+
|    101 | Raju  | Rastogi | Manager | Loan |  68647 |
+--------+-------+---------+---------+------+--------+

    $ select * from employee2  where fname not  like "R%";
+--------+---------+----------+------------+------------+--------+
| emp_id | fname   | lname    | desig      | dept       | salary |
+--------+---------+----------+------------+------------+--------+
|    102 | Sham    | Mohan    | Casier     | Cash       |  12300 |
|    103 | Baburao | Apte     | Associate  | Loan       |  22561 |
|    104 | Paul    | Philip   | Accountant | Account    |  23032 |
|    105 | Alex    | Watt     | Associate  | Deposit    |  23945 |
+--------+---------+----------+------------+------------+--------+




UNIQUE CONSTRAINT
=================
    Constrain are additonaly fewautres to given to columns, all values in colun are uniquely
    $ create  table contact (mob varchar(14) unique);

CHECK CONSTRAINT
=================
    Like checking phone no of 10 digits ;

    $ create table contacts(name varchar(50), mob varchar(15) unique check (length(mob) >= 10));
    
    Now to third person he could'nt able to understand why this error happens
    $ insert into contacts values("james" , "091234");
ERROR 3819 (HY000): Check constraint 'contacts_chk_1' is violated.
    
    
    To above case 
    $ create table contacts2(
        name varchar(50), 
        mob varchar(15) unique, 
        constraint mob_no_less_than_10_digits check (length(mob) >= 10));

    $ insert into contacts2 values("james" , "091234");
ERROR 3819 (HY000): Check constraint 'mob_no_less_than_10_digits' is violated.




ALTER 
=====
    Adding/droping
    --------------
    It is for changing structure of table (adding or droping the table)


    $ ALTER TABLE contacts ADD COLUMN city varchar(40);
    $ alter table contacts drop column city;


    Rename
    ------
    Renaming Column Name : ALTER TABLE bankTable RENAME COLUMN old_emp TO emp_id;
    Renaming Table Name : 
        Method 1 => ALTER TABLE bankTable RENAME To bankTableNew;
        Method 2 => RENAME TABLE bankTable  To bankTableNew;


    If repective column has used in some constraint then we must delete that first in order to delete it .


    MODIFY
    ------
    like chaning datatype , Extra, Default of columns;

    ALTER TABLE  TableName  COLUMN  ColumnName  ----;

    $ alter table temp2 modify Id INT NOT NULL;
