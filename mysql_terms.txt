
NOT NULL
========

$ desc customers;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | YES  |     | NULL    |       |
| name  | varchar(100) | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

$ insert into customers(id)   values (132);
$ select * from customers;
+------+---------+
| id   | name    |
+------+---------+
|  411 | Pranjal |
|  101 | Ajmal   |
|  132 | NULL    |
+------+---------+

$ insert into customers values(NULL, NULL); 
Possible

    There is no sense in adding the null, to handle this

$ Create table customers 
    (
        id int not null ,
        name varchar(100) not null
    );

$  desc customer2;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| id    | int          | NO   |     | NULL    |       |
| name  | varchar(100) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+

Now we can't insert the null either way



Default
=======
    While inserting when we not assign value for particular column, default assigned to it. 
    Can used when we know that many will value will same in list

    $ create table customer3 ( id int not null , name varchar(50) not null, acc_type varchar(100) not null default 'Savings'); 

    $ desc customer3;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    |       |
| name     | varchar(50)  | NO   |     | NULL    |       |
| acc_type | varchar(100) | NO   |     | Savings |       |
+----------+--------------+------+-----+---------+-------+

    $ insert into customer3(id , name) values(123, "Kr");

    $ select * from customer3;
+-----+------+----------+
| id  | name | acc_type |
+-----+------+----------+
| 123 | Kr   | Savings  |
+-----+------+----------+





Primary Key
===========
    The primary key constraint uniquely indentifies each record in table .
    Primary key must contain UNIQUE values , & vannot containe NULL values.
    A table can have only ONE primary key

    $ create table customeers4 ( acc_no int primary key, name varchar(50) not null , acc_type  varchar(50) not null default 'Savuings');

    $  desc customeers4 ;
+----------+-------------+------+-----+----------+-------+
| Field    | Type        | Null | Key | Default  | Extra |
+----------+-------------+------+-----+----------+-------+
| acc_no   | int         | NO   | PRI | NULL     |       |
| name     | varchar(50) | NO   |     | NULL     |       |
| acc_type | varchar(50) | NO   |     | Savuings |       |
+----------+-------------+------+-----+----------+-------+

$ insert into customeers4(acc_no, name) values(001, "Pranjal");

$ select * from customeers4;
+--------+---------+----------+
| acc_no | name    | acc_type |
+--------+---------+----------+
|      1 | Pranjal | Savuings |
+--------+---------+----------+

$ insert into customeers4(acc_no, name) values(001, "Ram");
ERROR 1062 (23000): Duplicate entry '1' for key 'customeers4.PRIMARY'

Primary keys must contain UNIQUE values, and cannot contain NULL values


Auto Increment
---------------
$ create table customers (acc_no int primary key auto_increment, name varchar(100) not null,  acc_type varchar(50) not null default 'Savings');
$  desc customers;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| acc_no   | int          | NO   | PRI | NULL    | auto_increment |
| name     | varchar(100) | NO   |     | NULL    |                |
| acc_type | varchar(50)  | NO   |     | Savings |                |
+----------+--------------+------+-----+---------+----------------+

$ insert into customers(name) values("Raju"), ("Sham");

$ mysql> select * from customers;
+--------+------+----------+
| acc_no | name | acc_type |
+--------+------+----------+
|      1 | Raju | Savings  |
|      2 | Sham | Savings  |
+--------+------+----------+

$ insert into customers(acc_no , name) values(145,"Baburao"), (121,
"TotolaBhai");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
+--------+------------+----------+

$ insert into customers(name) values("Raskhan");
$ select * from customers;
+--------+------------+----------+
| acc_no | name       | acc_type |
+--------+------------+----------+
|      1 | Raju       | Savings  |
|      2 | Sham       | Savings  |
|    121 | TotolaBhai | Savings  |
|    145 | Baburao    | Savings  |
|    146 | Raskhan    | Savings  |
+--------+------------+----------+


Alias
=====
    To do more readable

$ select acc_no as "Account Number" from customers;
+----------------+
| Account Number |
+----------------+
|              1 |
|              2 |
|            121 |
|            145 |
|            146 |
+----------------+

Even more than one poxsib
$ select acc_no as "Account Number", name as "Customer Names" from customers;
+----------------+----------------+
| Account Number | Customer Names |
+----------------+----------------+
|              1 | Raju           |
|              2 | Sham           |
|            121 | TotolaBhai     |
|            145 | Baburao        |
|            146 | Raskhan        |
+----------------+----------------+




DISTINCT
========

    $ select dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Loan    |
| Account |
| Deposit |
+---------+
5 rows in set (0.00 sec)

    $ select distinct dept from employee2;
+---------+
| dept    |
+---------+
| Loan    |
| Cash    |
| Account |
| Deposit |
+---------+



    When it used with multiple column then only distinct combo will come (means it will not for particular check with all distinct columns)


    $  select fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
| Baburao | Apte    |
+---------+---------+

    $ select distinct fname , lname from employee2;
+---------+---------+
| fname   | lname   |
+---------+---------+
| Raju    | Rastogi |
| Sham    | Mohan   |
| Baburao | Apte    |
| Paul    | Philip  |
| Alex    | Watt    |
+---------+---------+






    ORDER UP
    ========
    Used for sorting 
    For Descending order -> DESC 

    $ select * from employee2 order by fname ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    105 | Alex    | Watt    | Associate  | Deposit |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    104 | Paul    | Philip  | Accountant | Account |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    102 | Sham    | Mohan   | Casier     | Cash    |
+--------+---------+---------+------------+---------+

    $ select * from employee2 order by fname desc ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    102 | Sham    | Mohan   | Casier     | Cash    |
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    104 | Paul    | Philip  | Accountant | Account |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    106 | Baburao | Apte    | Casier     | Account |
|    105 | Alex    | Watt    | Associate  | Deposit |
+--------+---------+---------+------------+---------+


    Now we can do do sorting by prefrence also   ORDER BY   column1 ,column2 ---;

    column1 is sorted first , then if column1 same then rest column2 prefer like this continues.



LIKE
=====
    Even works bettwer with different case (lowercase or uppercase)

    $ select * from  employees;
+--------+--------+------------+---------+
| emp_id | name   | desig      | dept    |
+--------+--------+------------+---------+
|    101 | Raju   | Manager    | Loan    |
|    103 | Paul   | Associate  | IT      |
|    104 | Alex   | Accountant | Account |
|    105 | Victor | Associate  | Deposit |
+--------+--------+------------+---------+

    $ select * from employees where desig like "%mAna%";
+--------+------+---------+------+
| emp_id | name | desig   | dept |
+--------+------+---------+------+
|    101 | Raju | Manager | Loan |
+--------------------------------+


    $ select * from  employees where name like "_a__";
+--------+------+-----------+------+
| emp_id | name | desig     | dept |
+--------+------+-----------+------+
|    101 | Raju | Manager   | Loan |
|    103 | Paul | Associate | IT   |
+--------+------+-----------+------+



LIMIT 
=====
    Its for showing only limited columns

    $ select * from  employee2 ;
+--------+---------+----------+------------+------------+
| emp_id | fname   | lname    | desig      | dept       |
+--------+---------+----------+------------+------------+
|    101 | Raju    | Rastogi  | Manager    | Loan       |
|    102 | Sham    | Mohan    | Casier     | Cash       |
|    103 | Baburao | Apte     | Associate  | Loan       |
|    104 | Paul    | Philip   | Accountant | Account    |
|    105 | Alex    | Watt     | Associate  | Deposit    |
|    106 | Baburao | Apte     | Casier     | Account    |
|    107 | James   | Moore    | Assistant  | HR         |
|    108 | David   | Brown    | Consultant | Sales      |
|    109 | David   | Davis    | Cashier    | Sales      |
|    110 | David   | Smith    | Analyst    | Operations |
|    111 | Michael | Brown    | Assistant  | Credit     |
|    112 | Lisa    | Miller   | Officer    | Sales      |
|    113 | Emily   | Johnson  | Clerk      | Accounts   |
|    114 | John    | Wilson   | Executive  | Compliance |



    $  select * from  employee2 limit 4 ;
+--------+---------+---------+------------+---------+
| emp_id | fname   | lname   | desig      | dept    |
+--------+---------+---------+------------+---------+
|    101 | Raju    | Rastogi | Manager    | Loan    |
|    102 | Sham    | Mohan   | Casier     | Cash    |
|    103 | Baburao | Apte    | Associate  | Loan    |
|    104 | Paul    | Philip  | Accountant | Account |
+--------+---------+---------+------------+---------+


    It can also be used with two to perform as range 
    LIMIT <start-1>, <no of terms> ;


   $ select * from  employee2 limit 4,5;
+--------+---------+---------+------------+------------+
| emp_id | fname   | lname   | desig      | dept       |
+--------+---------+---------+------------+------------+
|    105 | Alex    | Watt    | Associate  | Deposit    |
|    106 | Baburao | Apte    | Casier     | Account    |
|    107 | James   | Moore   | Assistant  | HR         |
|    108 | David   | Brown   | Consultant | Sales      |
|    109 | David   | Davis   | Cashier    | Sales      |
+--------+---------+---------+------------+------------+
 

   $ select * from employee2 order by fname desc limit 1;
+--------+-------+-------+--------+------+--------+
| emp_id | fname | lname | desig  | dept | salary |
+--------+-------+-------+--------+------+--------+
|    102 | Sham  | Mohan | Casier | Cash |  25000 |
+--------+-------+-------+--------+------+--------+




    COUNT 
    ====== 

   $  select count(*) from employees;
+----------+
| count(*) |
+----------+
|        4 |
+----------+

    $ select count(name) from employees;
+-------------+
| count(name) |
+-------------+
|           4 |
+-------------+


    $ select count(desig) from employees;
+--------------+
| count(desig) |
+--------------+
|            4 |
+--------------+

    To select the disctinct the desig;
    $ select count(distinct desig) from employees;
+-----------------------+
| count(distinct desig) |
+-----------------------+
|                     3 |
+-----------------------+

    Also can used in conditional counts 
    $ select count(*) from employee2 where dept="HR";
+----------+
| count(*) |
+----------+
|       27 |
+----------+


    GROUP BY
    ----- --
    =========

    $ SELECT DEPT  FROM employee2 GROUP by dept;
+------------+
| DEPT       |
+------------+
| Loan       |
| Cash       |
| Account    |
| Deposit    |
| HR         |
| Sales      |
| Operations |
| Credit     |
| Accounts   |
| Compliance |
| IT         |
| Loans      |
+------------+

    $ SELECT DEPT , COUNT(FNAME) from employee2 group by dept;
+------------+--------------+
| DEPT       | COUNT(FNAME) |
+------------+--------------+
| Loan       |            2 |
| Cash       |            1 |
| Account    |            2 |
| Deposit    |            1 |
| HR         |           27 |
| Sales      |           38 |
| Operations |           34 |
| Credit     |           40 |
| Accounts   |           44 |
| Compliance |           41 |
| IT         |           42 |
| Loans      |           34 |
+------------+--------------+

    Agrreate function dont work in ditinct , by it work in group by




    MAX & MIN
    ===========
    
        $  select * from employee2 limit 4;
+--------+---------+---------+------------+---------+--------+
| emp_id | fname   | lname   | desig      | dept    | salary |
+--------+---------+---------+------------+---------+--------+
|    101 | Raju    | Rastogi | Manager    | Loan    |  25000 |
|    102 | Sham    | Mohan   | Casier     | Cash    |  25000 |
|    103 | Baburao | Apte    | Associate  | Loan    |  25000 |
|    104 | Paul    | Philip  | Accountant | Account |  25000 |
+--------+---------+---------+------------+---------+--------+

    
